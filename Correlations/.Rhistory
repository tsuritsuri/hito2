# =========================================
# ANÁLISIS DE CORRELACIÓN - GLIDE SP & XP
# Código standalone completo
# =========================================
# Load necessary libraries
library(dplyr)
library(openxlsx)
# -------------------------
# 1. CARGAR Y PREPARAR DATOS
# -------------------------
cat("=== Cargando datos ===\n")
# Leer archivo RDS
data_glide <- readRDS("Rds/Glide.rds")
# Calculate pIC50 from IC50 (IC50 is in µM, needs to be converted to M)
data_glide <- data_glide %>%
mutate(pIC50 = -log10(IC50 * 1e-6))
# Renombrar columnas para consistencia
data_glide <- data_glide %>%
rename(
Protein = protein_id,
Pose = Pose,
Method = category
)
# Verificar número de compuestos únicos
n_compuestos_unicos <- data_glide %>%
distinct(Title) %>%
nrow()
cat("Compuestos únicos:", n_compuestos_unicos, "\n")
# Verificar y remover filas sin IC50
n_before <- nrow(data_glide)
data_glide <- data_glide %>% filter(!is.na(IC50))
n_after <- nrow(data_glide)
cat("Filas eliminadas sin IC50:", n_before - n_after, "\n")
# Separar SP y XP
glide_sp <- data_glide %>% filter(Method == "SP")
glide_xp <- data_glide %>% filter(Method == "XP")
cat("Filas SP:", nrow(glide_sp), "\n")
cat("Filas XP:", nrow(glide_xp), "\n")
cat("Frames únicos en SP:", n_distinct(glide_sp$frame), "\n")
cat("Frames únicos en XP:", n_distinct(glide_xp$frame), "\n\n")
# -------------------------
# 2. FUNCIONES DE DATA FUSION
# -------------------------
median_value <- function(data, energy_col) {
data %>%
group_by(Title) %>%
summarise(!!energy_col := median(.data[[energy_col]], na.rm = TRUE), .groups = "drop")
}
minimum_value <- function(data, energy_col, pose) {
data %>%
filter(Pose == pose) %>%
select(Title, !!energy_col)
}
arithmetic_mean <- function(data, energy_col) {
data %>%
group_by(Title) %>%
summarise(!!energy_col := mean(.data[[energy_col]], na.rm = TRUE), .groups = "drop")
}
geometric_mean <- function(data, energy_col) {
data %>%
group_by(Title) %>%
summarise(!!energy_col := sign(mean(.data[[energy_col]], na.rm = TRUE)) *
exp(mean(log(abs(.data[[energy_col]])), na.rm = TRUE)), .groups = "drop")
}
harmonic_mean <- function(data, energy_col) {
data %>%
group_by(Title) %>%
summarise(!!energy_col := sign(mean(.data[[energy_col]], na.rm = TRUE)) *
(n() / sum(1 / abs(.data[[energy_col]]), na.rm = TRUE)), .groups = "drop")
}
euclidean_mean <- function(data, energy_col) {
data %>%
group_by(Title) %>%
summarise(
!!energy_col := sign(mean(.data[[energy_col]], na.rm = TRUE)) *
sqrt(sum((.data[[energy_col]])^2, na.rm = TRUE) / n()),
.groups = "drop"
)
}
apply_data_fusion <- function(data, method, energy_col, pose = NULL) {
if (method == "Median") {
return(median_value(data, energy_col))
} else if (method == "Minimum") {
return(minimum_value(data, energy_col, pose))
} else if (method == "Arithmetic") {
return(arithmetic_mean(data, energy_col))
} else if (method == "Geometric") {
return(geometric_mean(data, energy_col))
} else if (method == "Harmonic") {
return(harmonic_mean(data, energy_col))
} else if (method == "Euclidean") {
return(euclidean_mean(data, energy_col))
} else {
stop("Invalid Data Fusion Method")
}
}
# -------------------------
# 3. FUNCIÓN IRM
# -------------------------
calculate_irm <- function(actual, predicted, threshold = 1.0) {
mean(abs(actual - predicted) <= threshold, na.rm = TRUE)
}
# -------------------------
# 4. FUNCIÓN PRINCIPAL DE ANÁLISIS
# -------------------------
run_correlation_analysis <- function(data, method_name, output_filename, variant = "1_1") {
cat("\n=== Iniciando análisis para", method_name, "===\n")
# Configuration
energy_columns <- c(
"docking.score", "glide.ligand.efficiency",
"glide.gscore", "glide.emodel",
"glide.energy", "glide.einternal"
)
exp_variables <- c("IC50", "pIC50")
fusion_methods <- c("Median", "Minimum", "Arithmetic", "Geometric", "Harmonic", "Euclidean")
# Results dataframe
results_df <- data.frame(
Protein     = character(),
Frame       = integer(),
ExpVariable = character(),
DataFusion  = character(),
EnergyTerm  = character(),
Pose        = integer(),
Pearson     = numeric(),
Spearman    = numeric(),
MAE         = numeric(),
RMSE        = numeric(),
IRM         = numeric(),
N           = integer(),
N_Ligands   = integer(),
Variant     = character(),
Method      = character(),
stringsAsFactors = FALSE
)
# Contadores
total_iterations <- 0
completed <- 0
# Iterate over each protein
for (protein_name in unique(data$Protein)) {
data_protein <- data %>% filter(Protein == protein_name)
# Iterate over each frame within the protein
for (frame_num in unique(data_protein$frame)) {
cat("Procesando:", protein_name, "- Frame:", frame_num, "\n")
data_protein_frame <- data_protein %>%
filter(frame == frame_num)
for (fusion_method in fusion_methods) {
# For Minimum start at pose 1, for others start at pose 2
start_pose <- ifelse(fusion_method == "Minimum", 1, 2)
for (i in start_pose:10) {
# Filter by maximum number of poses
filtered_data <- data_protein_frame %>%
filter(Pose <= i)
for (energy_col in energy_columns) {
# Apply Data Fusion
if (fusion_method == "Minimum") {
fused_data <- apply_data_fusion(filtered_data, fusion_method, energy_col, pose = i)
} else {
fused_data <- apply_data_fusion(filtered_data, fusion_method, energy_col)
}
# Detect fused energy column name
fusion_col_name <- colnames(fused_data)[colnames(fused_data) != "Title"]
# Merge with experimental data
merged_data <- fused_data %>%
left_join(
data_protein_frame %>%
select(Title, all_of(exp_variables)) %>%
distinct(),
by = "Title"
)
